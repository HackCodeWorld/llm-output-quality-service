{"code": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 1593.0919189453125}
{"code": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == \"(\":\n            current_depth += 1\n            current_string.append(c)\n        elif c == \")\":\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(\"\".join(current_string))\n                current_string.clear()\n\n    return result\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 243.20889282226562}
{"code": "def truncate_number(number: float) -> float:\n    return number % 1.0\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 190.0479736328125}
{"code": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 197.3369140625}
{"code": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 198.35781860351562}
{"code": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 221.59600830078125}
{"code": "from typing import List\ndef parse_paren_group(s):\n    def parse_paren_group(s):\n            depth = 0\n            max_depth = 0\n            for c in s:\n                if c == '(':\n                    depth += 1\n                    max_depth = max(depth, max_depth)\n                else:\n                    depth -= 1\n\n            return max_depth\n\n        return [parse_paren_group(x) for x in paren_string.split(' ') if x]", "syntax_ok": false, "test_results": [{"caseId": "raw", "errors": ["  File \"/code/test.py\", line 15", "    return [parse_paren_group(x) for x in paren_string.split(' ') if x]", "                                                                       ^", "IndentationError: unindent does not match any outer indentation level"]}], "exec_time_ms": 169.68011474609375}
{"code": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [x for x in strings if substring in x]\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 232.84005737304688}
{"code": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 259.69696044921875}
{"code": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 257.6429748535156}
{"code": "def is_palindrome(string: str) -> bool:\n    if not string:\n        return \"\"\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n", "syntax_ok": true, "test_results": [{"caseId": "raw", "errors": ["Traceback (most recent call last):", "  File \"/code/test.py\", line 29, in <module>", "    check(make_palindrome)", "NameError: name 'make_palindrome' is not defined. Did you mean: 'is_palindrome'?"]}], "exec_time_ms": 175.578125}
{"code": "from typing import List\ndef xor(i, j):\n    def xor(i, j):\n            if i == j:\n                return '0'\n            else:\n                return '1'\n\n        return ''.join(xor(x, y) for x, y in zip(a, b))", "syntax_ok": false, "test_results": [{"caseId": "raw", "errors": ["  File \"/code/test.py\", line 9", "    return ''.join(xor(x, y) for x, y in zip(a, b))", "                                                   ^", "IndentationError: unindent does not match any outer indentation level"]}], "exec_time_ms": 185.65081787109375}
{"code": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 359.8771057128906}
{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 199.94497680664062}
{"code": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[: i + 1])\n    return result\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 229.02584838867188}
{"code": "def string_sequence(n: int) -> str:\n    return \" \".join([str(x) for x in range(n + 1)])\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 196.98309326171875}
{"code": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 169.24691772460938}
{"code": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    return [note_map[x] for x in music_string.split(\" \") if x]\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 195.71495056152344}
{"code": "def how_many_times(string: str, substring: str) -> int:\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i : i + len(substring)] == substring:\n            times += 1\n\n    return times\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 178.832763671875}
{"code": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    value_map = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    return \" \".join(\n        sorted([x for x in numbers.split(\" \") if x], key=lambda x: value_map[x])\n    )\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 182.18087768554688}
{"code": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 190.75608825683594}
{"code": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 266.7732238769531}
{"code": "from typing import Any, List\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 215.1167449951172}
{"code": "def strlen(string: str) -> int:\n    return len(string)\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 158.94412231445312}
{"code": "def largest_divisor(n: int) -> int:\n    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n", "syntax_ok": true, "test_results": [{"caseId": "raw"}], "exec_time_ms": 178.1837921142578}
